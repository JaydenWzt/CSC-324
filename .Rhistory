total_covid_death <- world_covid_data %>%
group_by(location) %>%
reframe(total_deaths = sum(new_deaths, na.rm = TRUE)) %>%
rename('country' = 'location')
total_covid_death[total_covid_death == 0] <- NA
# the total number of death for each country
monthly_new_covid <- world_covid_data %>%
mutate(month = paste(substr(date, 1, 4),
substr(date, 6, 7),
sep = '')) %>%
group_by(location, month) %>%
reframe(monthly_new_cases = sum(new_cases, na.rm = TRUE),
monthly_new_deaths = sum(new_deaths, na.rm = TRUE)) %>%
rename('country' = 'location')
monthly_new_covid[monthly_new_covid == 0] <- NA
# new cases and new death are adjusted to monthly level with 'location' and 'month', other numbers all excluded.
# this data frame still contain data at levels other than national. These data will keep remain here until I match the 'location' in in this data frame with 'country_short_name' in world_pop_data_clean. 'location' not included in 'country_short_name' will be excluded since latitude and longitude are required to plot the global map.
#processing gov_re_data
gov_policies_eval <- gov_re_data %>%
group_by(CountryName) %>%
reframe(testing_policy = mean(H2_Testing.policy, na.rm = TRUE),
vaccination_policy = mean(H7_Vaccination.policy, na.rm = TRUE)) %>%
rename('country' = 'CountryName')
gov_policies_eval[gov_policies_eval == 0] <- NA
# I arbitrarily choose only to look at the effects of testing policy and vaccination policy for each country.
#All 'country' in each data frame should match, 'country' not existed in 'world_pop_data_clean' will be excluded
# In 'total_covid_death', exclude observations that has 'country' not in 'world_pop_data_clean'
total_covid_death <- total_covid_death %>%
filter(country %in% world_pop_data_clean$country)
# In 'monthly_new_covid', exclude observations that has 'country' not in 'world_pop_data_clean'
monthly_new_covid <- monthly_new_covid %>%
filter(country %in% world_pop_data_clean$country)
# In 'gov_policies_eval', exclude observations that has 'country' not in 'world_pop_data_clean'
gov_policies_eval <- gov_policies_eval %>%
filter(country %in% world_pop_data_clean$country)
# Feed back all the three cleaned data sets to 'world_pop_data_clean' so all four data sets have identical 'country' entries
world_pop_data_clean <- world_pop_data_clean %>%
filter(country %in% gov_policies_eval$country) %>%
filter(country %in% monthly_new_covid$country) %>%
filter(country %in% total_covid_death$country)
# total_covid_death and gov_policies_eval are combined, and death are adjusted to death per million
covid_death_with_policy <- total_covid_death %>%
merge(world_pop_data_clean, by = 'country') %>%
merge(gov_policies_eval, by = 'country') %>%
mutate(death_per_m = (total_deaths/geo_region_population_count)*1000000) %>%
filter(not(death_per_m %in% Inf)) %>%
select(-c(total_deaths, geo_region_population_count, geo_latitude, geo_longitude)) %>%
mutate(across(where(is.numeric), ~round(., 2))) %>%
mutate(death_per_m = round(.$death_per_m, 0))
monthly_covid_death <- monthly_new_covid %>%
merge(world_pop_data_clean, by = 'country') %>%
select(-c(geo_region_population_count))
print(monthly_new_covid)
# processing gov_re_data and total_covid_death will be combined based on country name to see if there exists correlation between policies taken and the actual results(evaluated by number of death)
knitr::opts_chunk$set(echo = TRUE)
#importing libraries
library(dplyr)
library(magrittr)
library(tidyr)
library(formatR)
library(stringr)
library(arsenal)
library(formattable)
world_covid_data <- read.csv('./Dataset/full_data.csv')
world_pop_data <- read.csv('./Dataset/master_location_pop_table.csv')
gov_re_data <- read.csv('./Dataset/OxCGRT_latest.csv')
#colnames(gov_re_data)
#processing world_pop_data
world_pop_data_clean <- world_pop_data %>%
#select(-c(country_alpha_3_code:county_fips_number, data_source_name, geo_location)) %>%
group_by(country_short_name) %>%
summarise(geo_latitude = mean(geo_latitude),
geo_longitude = mean(geo_longitude),
geo_region_population_count = sum(geo_region_population_count)) %>%
rename('country' = 'country_short_name')
# Only kept 'geo_latitude', 'geo_longitude' and 'geo_region_population_count', all changed to national level. Other data excluded.
#processing world_covid_data
#colnames(world_covid_data)
total_covid_death <- world_covid_data %>%
group_by(location) %>%
reframe(total_deaths = sum(new_deaths, na.rm = TRUE)) %>%
rename('country' = 'location')
total_covid_death[total_covid_death == 0] <- NA
# the total number of death for each country
monthly_new_covid <- world_covid_data %>%
mutate(month = paste(substr(date, 1, 4),
substr(date, 6, 7),
sep = '')) %>%
group_by(location, month) %>%
reframe(monthly_new_cases = sum(new_cases, na.rm = TRUE),
monthly_new_deaths = sum(new_deaths, na.rm = TRUE)) %>%
rename('country' = 'location')
monthly_new_covid[monthly_new_covid == 0] <- NA
# new cases and new death are adjusted to monthly level with 'location' and 'month', other numbers all excluded.
# this data frame still contain data at levels other than national. These data will keep remain here until I match the 'location' in in this data frame with 'country_short_name' in world_pop_data_clean. 'location' not included in 'country_short_name' will be excluded since latitude and longitude are required to plot the global map.
#processing gov_re_data
gov_policies_eval <- gov_re_data %>%
group_by(CountryName) %>%
reframe(testing_policy = mean(H2_Testing.policy, na.rm = TRUE),
vaccination_policy = mean(H7_Vaccination.policy, na.rm = TRUE)) %>%
rename('country' = 'CountryName')
gov_policies_eval[gov_policies_eval == 0] <- NA
# I arbitrarily choose only to look at the effects of testing policy and vaccination policy for each country.
#All 'country' in each data frame should match, 'country' not existed in 'world_pop_data_clean' will be excluded
# In 'total_covid_death', exclude observations that has 'country' not in 'world_pop_data_clean'
total_covid_death <- total_covid_death %>%
filter(country %in% world_pop_data_clean$country)
# In 'monthly_new_covid', exclude observations that has 'country' not in 'world_pop_data_clean'
monthly_new_covid <- monthly_new_covid %>%
filter(country %in% world_pop_data_clean$country)
# In 'gov_policies_eval', exclude observations that has 'country' not in 'world_pop_data_clean'
gov_policies_eval <- gov_policies_eval %>%
filter(country %in% world_pop_data_clean$country)
# Feed back all the three cleaned data sets to 'world_pop_data_clean' so all four data sets have identical 'country' entries
world_pop_data_clean <- world_pop_data_clean %>%
filter(country %in% gov_policies_eval$country) %>%
filter(country %in% monthly_new_covid$country) %>%
filter(country %in% total_covid_death$country)
# total_covid_death and gov_policies_eval are combined, and death are adjusted to death per million
covid_death_with_policy <- total_covid_death %>%
merge(world_pop_data_clean, by = 'country') %>%
merge(gov_policies_eval, by = 'country') %>%
mutate(death_per_m = (total_deaths/geo_region_population_count)*1000000) %>%
filter(not(death_per_m %in% Inf)) %>%
select(-c(total_deaths, geo_region_population_count, geo_latitude, geo_longitude)) %>%
mutate(across(where(is.numeric), ~round(., 2))) %>%
mutate(death_per_m = round(.$death_per_m, 0))
monthly_covid_death <- monthly_new_covid %>%
merge(world_pop_data_clean, by = 'country') #%>%
#select(-c(geo_region_population_count))
print(monthly_new_covid)
# processing gov_re_data and total_covid_death will be combined based on country name to see if there exists correlation between policies taken and the actual results(evaluated by number of death)
# total_covid_death and gov_policies_eval are combined, and death are adjusted to death per million
covid_death_with_policy <- total_covid_death %>%
merge(world_pop_data_clean, by = 'country') %>%
merge(gov_policies_eval, by = 'country') %>%
mutate(death_per_m = (total_deaths/geo_region_population_count)*1000000) %>%
filter(not(death_per_m %in% Inf)) %>%
select(-c(total_deaths, geo_region_population_count, geo_latitude, geo_longitude)) %>%
mutate(across(where(is.numeric), ~round(., 2))) %>%
mutate(death_per_m = round(.$death_per_m, 0))
monthly_covid_death <- monthly_new_covid %>%
merge(world_pop_data_clean, by = 'country') #%>%
#select(-c(geo_region_population_count))
print(monthly_covid_death)
# processing gov_re_data and total_covid_death will be combined based on country name to see if there exists correlation between policies taken and the actual results(evaluated by number of death)
monthly_covid_death <- monthly_new_covid %>%
merge(world_pop_data_clean, by = 'country') %>%
select(-c(geo_region_population_count)) %>%
mutate(geo_latitude = round(.$geo_latitude, 0)) %>%
mutate(geo_longitude = round(.$geo_longitude, 0))
print(monthly_covid_death)
# total_covid_death and gov_policies_eval are combined, and death are adjusted to death per million
covid_death_with_policy <- total_covid_death %>%
merge(world_pop_data_clean, by = 'country') %>%
merge(gov_policies_eval, by = 'country') %>%
mutate(death_per_m = (total_deaths/geo_region_population_count)*1000000) %>%
filter(not(death_per_m %in% Inf)) %>%
select(-c(total_deaths, geo_region_population_count, geo_latitude, geo_longitude)) %>%
mutate(across(where(is.numeric), ~round(., 2))) %>%
mutate(death_per_m = round(.$death_per_m, 0))
monthly_covid_death <- monthly_new_covid %>%
merge(world_pop_data_clean, by = 'country') %>%
select(-c(geo_region_population_count)) %>%
mutate(geo_latitude = round(.$geo_latitude, 2)) %>%
mutate(geo_longitude = round(.$geo_longitude, 2))
print(monthly_covid_death)
# processing gov_re_data and total_covid_death will be combined based on country name to see if there exists correlation between policies taken and the actual results(evaluated by number of death)
# total_covid_death and gov_policies_eval are combined, and death are adjusted to death per million
covid_death_with_policy <- total_covid_death %>%
merge(world_pop_data_clean, by = 'country') %>%
merge(gov_policies_eval, by = 'country') %>%
mutate(death_per_m = (total_deaths/geo_region_population_count)*1000000) %>%
filter(not(death_per_m %in% Inf)) %>%
select(-c(total_deaths, geo_region_population_count, geo_latitude, geo_longitude)) %>%
mutate(across(where(is.numeric), ~round(., 2))) %>%
mutate(death_per_m = round(.$death_per_m, 0))
monthly_covid_deaths <- monthly_new_covid %>%
merge(world_pop_data_clean, by = 'country') %>%
select(-c(geo_region_population_count, monthly_new_cases)) %>%
mutate(geo_latitude = round(.$geo_latitude, 2)) %>%
mutate(geo_longitude = round(.$geo_longitude, 2))
monthly_covid_cases <- monthly_new_covid %>%
merge(world_pop_data_clean, by = 'country') %>%
select(-c(geo_region_population_count, monthly_new_deaths)) %>%
mutate(geo_latitude = round(.$geo_latitude, 2)) %>%
mutate(geo_longitude = round(.$geo_longitude, 2))
# processing gov_re_data and total_covid_death will be combined based on country name to see if there exists correlation between policies taken and the actual results(evaluated by number of death)
# create a new data frame named covid_death_with_policy that have total_covid_death and gov_policies_evalcombined
covid_death_with_policy <- total_covid_death %>%
# Adding in world_pop_data_clean
merge(world_pop_data_clean, by = 'country') %>%
# Adding in gov_policies_eval
merge(gov_policies_eval, by = 'country') %>%
# Death are adjusted to death per million
mutate(death_per_m = (total_deaths/geo_region_population_count)*1000000) %>%
filter(not(death_per_m %in% Inf)) %>%
# Exclude useless columns
select(-c(total_deaths, geo_region_population_count, geo_latitude, geo_longitude)) %>%
# Rounding decimals to increase readability
mutate(across(where(is.numeric), ~round(., 2))) %>%
mutate(death_per_m = round(.$death_per_m, 0))
# create a new data frame about monthly covid death
monthly_covid_deaths <- monthly_new_covid %>%
# Adding in world_pop_data_clean
merge(world_pop_data_clean, by = 'country') %>%
# Exclude useless columns
select(-c(geo_region_population_count, monthly_new_cases)) %>%
# Rounding decimals
mutate(geo_latitude = round(.$geo_latitude, 2)) %>%
mutate(geo_longitude = round(.$geo_longitude, 2))
# Create a new data frame about monthly covid cases
monthly_covid_cases <- monthly_new_covid %>%
# Adding in world_pop_data_clean
merge(world_pop_data_clean, by = 'country') %>%
# Exclude useless columns
select(-c(geo_region_population_count, monthly_new_deaths)) %>%
# Rounding decimals
mutate(geo_latitude = round(.$geo_latitude, 2)) %>%
mutate(geo_longitude = round(.$geo_longitude, 2))
View(monthly_covid_death)
knitr::opts_chunk$set(echo = TRUE)
#importing libraries
library(dplyr)
library(magrittr)
library(tidyr)
library(formatR)
library(stringr)
library(arsenal)
library(formattable)
world_covid_data <- read.csv('./Dataset/full_data.csv')
world_pop_data <- read.csv('./Dataset/master_location_pop_table.csv')
gov_re_data <- read.csv('./Dataset/OxCGRT_latest.csv')
#colnames(gov_re_data)
#processing world_pop_data
world_pop_data_clean <- world_pop_data %>%
#select(-c(country_alpha_3_code:county_fips_number, data_source_name, geo_location)) %>%
group_by(country_short_name) %>%
summarise(geo_latitude = mean(geo_latitude),
geo_longitude = mean(geo_longitude),
geo_region_population_count = sum(geo_region_population_count)) %>%
rename('country' = 'country_short_name')
# Only kept 'geo_latitude', 'geo_longitude' and 'geo_region_population_count', all changed to national level. Other data excluded.
#processing world_covid_data
#colnames(world_covid_data)
total_covid_death <- world_covid_data %>%
group_by(location) %>%
reframe(total_deaths = sum(new_deaths, na.rm = TRUE)) %>%
rename('country' = 'location')
total_covid_death[total_covid_death == 0] <- NA
# the total number of death for each country
monthly_new_covid <- world_covid_data %>%
mutate(month = paste(substr(date, 1, 4),
substr(date, 6, 7),
sep = '')) %>%
group_by(location, month) %>%
reframe(monthly_new_cases = sum(new_cases, na.rm = TRUE),
monthly_new_deaths = sum(new_deaths, na.rm = TRUE)) %>%
rename('country' = 'location')
monthly_new_covid[monthly_new_covid == 0] <- NA
# new cases and new death are adjusted to monthly level with 'location' and 'month', other numbers all excluded.
# this data frame still contain data at levels other than national. These data will keep remain here until I match the 'location' in in this data frame with 'country_short_name' in world_pop_data_clean. 'location' not included in 'country_short_name' will be excluded since latitude and longitude are required to plot the global map.
#processing gov_re_data
gov_policies_eval <- gov_re_data %>%
group_by(CountryName) %>%
reframe(testing_policy = mean(H2_Testing.policy, na.rm = TRUE),
vaccination_policy = mean(H7_Vaccination.policy, na.rm = TRUE)) %>%
rename('country' = 'CountryName')
gov_policies_eval[gov_policies_eval == 0] <- NA
# I arbitrarily choose only to look at the effects of testing policy and vaccination policy for each country.
#All 'country' in each data frame should match, 'country' not existed in 'world_pop_data_clean' will be excluded
# In 'total_covid_death', exclude observations that has 'country' not in 'world_pop_data_clean'
total_covid_death <- total_covid_death %>%
filter(country %in% world_pop_data_clean$country)
# In 'monthly_new_covid', exclude observations that has 'country' not in 'world_pop_data_clean'
monthly_new_covid <- monthly_new_covid %>%
filter(country %in% world_pop_data_clean$country)
# In 'gov_policies_eval', exclude observations that has 'country' not in 'world_pop_data_clean'
gov_policies_eval <- gov_policies_eval %>%
filter(country %in% world_pop_data_clean$country)
# Feed back all the three cleaned data sets to 'world_pop_data_clean' so all four data sets have identical 'country' entries
world_pop_data_clean <- world_pop_data_clean %>%
filter(country %in% gov_policies_eval$country) %>%
filter(country %in% monthly_new_covid$country) %>%
filter(country %in% total_covid_death$country)
# create a new data frame named covid_death_with_policy that have total_covid_death and gov_policies_evalcombined
covid_death_with_policy <- total_covid_death %>%
# Adding in world_pop_data_clean
merge(world_pop_data_clean, by = 'country') %>%
# Adding in gov_policies_eval
merge(gov_policies_eval, by = 'country') %>%
# Death are adjusted to death per million
mutate(death_per_m = (total_deaths/geo_region_population_count)*1000000) %>%
filter(not(death_per_m %in% Inf)) %>%
# Exclude useless columns
select(-c(total_deaths, geo_region_population_count, geo_latitude, geo_longitude)) %>%
# Rounding decimals to increase readability
mutate(across(where(is.numeric), ~round(., 2))) %>%
mutate(death_per_m = round(.$death_per_m, 0))
# create a new data frame about monthly covid death
monthly_covid_deaths <- monthly_new_covid %>%
# Adding in world_pop_data_clean
merge(world_pop_data_clean, by = 'country') %>%
# Exclude useless columns
select(-c(geo_region_population_count, monthly_new_cases)) %>%
# Rounding decimals
mutate(geo_latitude = round(.$geo_latitude, 2)) %>%
mutate(geo_longitude = round(.$geo_longitude, 2))
# Create a new data frame about monthly covid cases
monthly_covid_cases <- monthly_new_covid %>%
# Adding in world_pop_data_clean
merge(world_pop_data_clean, by = 'country') %>%
# Exclude useless columns
select(-c(geo_region_population_count, monthly_new_deaths)) %>%
# Rounding decimals
mutate(geo_latitude = round(.$geo_latitude, 2)) %>%
mutate(geo_longitude = round(.$geo_longitude, 2))
View(monthly_new_covid)
knitr::opts_chunk$set(echo = TRUE)
#importing libraries
library(dplyr)
library(magrittr)
library(tidyr)
library(formatR)
library(stringr)
library(arsenal)
library(formattable)
worldMaps <- function(df, world_data, data_type, period, indicator){
# Function for setting the aesthetics of the plot
my_theme <- function () {
theme_bw() + theme(axis.text = element_text(size = 14),
axis.title = element_text(size = 14),
strip.text = element_text(size = 14),
panel.grid.major = element_blank(),
panel.grid.minor = element_blank(),
panel.background = element_blank(),
legend.position = "bottom",
panel.border = element_blank(),
strip.background = element_rect(fill = 'white', colour = 'white'))
}
# Select only the data that the user has selected to view
plotdf <- df[df$Indicator == indicator & df$DataType == data_type & df$Period == period,]
plotdf <- plotdf[!is.na(plotdf$ISO3), ]
# Add the data the user wants to see to the geographical world data
world_data['DataType'] <- rep(data_type, nrow(world_data))
world_data['Period'] <- rep(period, nrow(world_data))
world_data['Indicator'] <- rep(indicator, nrow(world_data))
world_data['Value'] <- plotdf$Value[match(world_data$ISO3, plotdf$ISO3)]
# Create caption with the data source to show underneath the map
capt <- paste0("Source: ", ifelse(data_type == "Childlessness", "United Nations" , "World Bank"))
# Specify the plot for the world map
library(RColorBrewer)
library(ggiraph)
g <- ggplot() +
geom_polygon_interactive(data = world_data, color = 'gray70', size = 0.1,
aes(x = long, y = lat, fill = Value, group = group,
tooltip = sprintf("%s<br/>%s", ISO3, Value))) +
scale_fill_gradientn(colours = brewer.pal(5, "RdBu"), na.value = 'white') +
scale_y_continuous(limits = c(-60, 90), breaks = c()) +
scale_x_continuous(breaks = c()) +
labs(fill = data_type, color = data_type, title = NULL, x = NULL, y = NULL, caption = capt) +
my_theme()
return(g)
}
## Building in R Shiny
```{R}
library(shiny)
library(ggiraph)
install.packages("ggiraph")
library(shiny)
library(ggiraph)
shinyApp(
# Define the UI
ui = fluidPage(
# App title
titlePanel("Childlessness and Gender Gap Index Data"),
# Sidebar layout with input and output definitions
sidebarLayout(
# Sidebar panel for inputs
sidebarPanel(
# First input: Type of data
selectInput(inputId = "data_type",
label = "Choose the type of data you want to see:",
choices = list("Childlessness" = "Childlessness", "Gender Gap Index" = "Gender Gap Index")),
# Second input (choices depend on the choice for the first input)
uiOutput("secondSelection"),
# Third input (choices depend on the choice for the first and second input)
uiOutput("thirdSelection")
),
# Main panel for displaying outputs
mainPanel(
# Hide errors
tags$style(type = "text/css",
".shiny-output-error { visibility: hidden; }",
".shiny-output-error:before { visibility: hidden; }"),
# Output: interactive world map
girafeOutput("distPlot")
)
)
),
# Define the server
server = function(input, output) {
# Create the interactive world map
output$distPlot <- renderGirafe({
ggiraph(code = print(worldMaps(df, world_data, input$data_type, input$period, input$indicator)))
})
# Change the choices for the second selection on the basis of the input to the first selection
output$secondSelection <- renderUI({
choice_second <- as.list(unique(df$Period[which(df$DataType == input$data_type)]))
selectInput(inputId = "period", choices = choice_second,
label = "Choose the period for which you want to see the data:")
})
# Change the choices for the third selection on the basis of the input to the first and second selections
output$thirdSelection <- renderUI({
lab <- ifelse(input$data_type == "Childlessness", "age group", "indicator")
choice_third <- as.list(unique(df$Indicator[df$DataType == input$data_type & df$Period == input$period]))
selectInput(inputId = "indicator", choices = choice_third,
label = paste0("Choose the type of ", lab, " you want to explore:"))
})
},
options = list(height = 600)
shinyApp(ui = ui, server = server)
worldMaps <- function(df, world_data, data_type, period, indicator){
# Function for setting the aesthetics of the plot
my_theme <- function () {
theme_bw() + theme(axis.text = element_text(size = 14),
axis.title = element_text(size = 14),
strip.text = element_text(size = 14),
panel.grid.major = element_blank(),
panel.grid.minor = element_blank(),
panel.background = element_blank(),
legend.position = "bottom",
panel.border = element_blank(),
strip.background = element_rect(fill = 'white', colour = 'white'))
}
# Select only the data that the user has selected to view
plotdf <- df[df$Indicator == indicator & df$DataType == data_type & df$Period == period,]
plotdf <- plotdf[!is.na(plotdf$ISO3), ]
# Add the data the user wants to see to the geographical world data
world_data['DataType'] <- rep(data_type, nrow(world_data))
world_data['Period'] <- rep(period, nrow(world_data))
world_data['Indicator'] <- rep(indicator, nrow(world_data))
world_data['Value'] <- plotdf$Value[match(world_data$ISO3, plotdf$ISO3)]
# Create caption with the data source to show underneath the map
capt <- paste0("Source: ", ifelse(data_type == "Childlessness", "United Nations" , "World Bank"))
# Specify the plot for the world map
library(RColorBrewer)
library(ggiraph)
g <- ggplot() +
geom_polygon_interactive(data = world_data, color = 'gray70', size = 0.1,
aes(x = long, y = lat, fill = Value, group = group,
tooltip = sprintf("%s<br/>%s", ISO3, Value))) +
scale_fill_gradientn(colours = brewer.pal(5, "RdBu"), na.value = 'white') +
scale_y_continuous(limits = c(-60, 90), breaks = c()) +
scale_x_continuous(breaks = c()) +
labs(fill = data_type, color = data_type, title = NULL, x = NULL, y = NULL, caption = capt) +
my_theme()
return(g)
}
library(shiny)
library(ggiraph)
shinyApp(
# Define the UI
ui = fluidPage(
# App title
titlePanel("Childlessness and Gender Gap Index Data"),
# Sidebar layout with input and output definitions
sidebarLayout(
# Sidebar panel for inputs
sidebarPanel(
# First input: Type of data
selectInput(inputId = "data_type",
label = "Choose the type of data you want to see:",
choices = list("Childlessness" = "Childlessness", "Gender Gap Index" = "Gender Gap Index")),
# Second input (choices depend on the choice for the first input)
uiOutput("secondSelection"),
# Third input (choices depend on the choice for the first and second input)
uiOutput("thirdSelection")
),
# Main panel for displaying outputs
mainPanel(
# Hide errors
tags$style(type = "text/css",
".shiny-output-error { visibility: hidden; }",
".shiny-output-error:before { visibility: hidden; }"),
# Output: interactive world map
girafeOutput("distPlot")
)
)
),
# Define the server
server = function(input, output) {
# Create the interactive world map
output$distPlot <- renderGirafe({
ggiraph(code = print(worldMaps(df, world_data, input$data_type, input$period, input$indicator)))
})
# Change the choices for the second selection on the basis of the input to the first selection
output$secondSelection <- renderUI({
choice_second <- as.list(unique(df$Period[which(df$DataType == input$data_type)]))
selectInput(inputId = "period", choices = choice_second,
label = "Choose the period for which you want to see the data:")
})
# Change the choices for the third selection on the basis of the input to the first and second selections
output$thirdSelection <- renderUI({
lab <- ifelse(input$data_type == "Childlessness", "age group", "indicator")
choice_third <- as.list(unique(df$Indicator[df$DataType == input$data_type & df$Period == input$period]))
selectInput(inputId = "indicator", choices = choice_third,
label = paste0("Choose the type of ", lab, " you want to explore:"))
})
},
options = list(height = 600)
)
